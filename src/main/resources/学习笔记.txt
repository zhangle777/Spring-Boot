select * from information_schema.innodb_trx 锁库查询


spring 事务机制：默认情况下只回滚运行时异常！！

java 标识符：只能有 字母、数字、下划线、美元符($) 不能以数字开头
java重写：重写要求方法名和方法参数必须相同，返回值可以是被重写方法的子类，访问修饰符不能比被重写方法小。抛出异常不能比被重写方法小。（两同两大一小）
java重载：同一个类中，有多个方法名称相同，但参数类型不同的方法。就叫重载。重载跟方法的返回值和访问修饰符没有关系。
位运算：
	补码：二进制先取反再加一。
	位与&：两个二进制值，相应位都为1时则为1。否则为0(同一为一)
	位或|：两个二进制值，相应位只要存在1则为1。否则为0（有一为一）
	位异或^：两个二进制值，相应位不相同时则为1。否则为0（不同为一）
	左移<<：运算对象全部向左移动若干位，左边的二进制丢弃，右边补0
	带符号右移>>：运算对象全部向右移动若干位，右边的二进制丢弃。正数左边补0，负数就补1
	无符号右移>>>：运算对象全部向右移动若干位，右边的二进制丢弃。左边统统补0
HashMap：jdk1.8之前采用（数组+连表）的数据结构。1.8之后则采用（数组+链表+红黑树）数据结构。继承AbstractMap实现Map、Cloneable、Serializable等接口。
	实现的是浅拷贝。即改变原始对象，拷贝对象也会发生改变.

HashMap的put()方法原理(jdk1.8)：
	1.首先获取key的hashCode，然后将hashcode值右移16位。然后再将右移后的值与原hashcode值异或运算，得到最终的hashcode。
		(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)，这样做称为扰动计算。在jdk1.7时，一共做了4次扰动计算。这种计算方式可以很大程度减少碰撞几率
	2.初始化数组表table的容量。容量都是2的次幂。默认是16，即new HashMap()操作。
	3.通过key的hashCode查询在数组中的位置，即下标i=(n-1)&hash,使用位与运算等同于取模运算hash%n。但效率高于后者
	4.如果第三步数组 table[i]中为null 则直接在该下标处添加。如果table[i]中不为null。已存在时。则判断key的hash值是否等于table[i]的hash值和key是否等于table[i]的key。即
		p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))) 如果都相等，则直接覆盖该位置的数据。而如果不相等时，再判断table[i]是否为树节点。
	  如果是，直接添加树节点。如果不是树节点，则遍历链表，并找到table[i]的下节点，如果没有下节点，则直接将当前节点添加。并判断循环的次数（默认是8次）是否满足红黑树结构，
	  如果满足则会将链表结构转为红黑树结构。如果已有下节点，则判断下节点的hash是否相等，如果相等则直接覆盖。并返回上级节点。即table[i]。
	5.最后结构修改，判断是否需要扩容。HashMap每次扩容为原来的2倍。

HashMap解决hash冲突的方法为链地址法。

equlas相等则hashcode一定相等。hashcode相等但equlas不一定相等

HashMap与HashTable的区别：
	1.安全性：HashMap线程不安全，HashTable为线程安全
	2.继承链：HashMap继承AbstractMap，HashTable继承Dictionary。但都实现了Map以及cloneable、Serializable接口。
	3.存空值：HaspMap允许key或value为null，HashTable不允许key或value为null
	4.容量与扩容：HashMap默认容量为16，每次扩容为原来的2n，HashTable默认容量为11，每次扩容为原来的2n+1;

Math.ceil()：表示向上取整，返回不小于它的最小整数。返回值为double类型。注意：如果有符号。则符号不变。
	例：Math.ceil(-0.5) = -0.0
Math.floor()：表示向下取整，返回不大于它的最大整数，返回值为double类型
Math.round()：表示四舍五入，算法为Math.floor(a+0.5),即将原值加0.5再向下取整。返回值为int或long型。

静态方法可以被继承，但不能被重写，不能有@Override注解。private修饰的方法不能被继承。

getMethod():获取当前类及所有继承的父类的public修饰的方法。仅包括public
getDeclaredMethod():获取当前类的所有方法，包括public/private/protected/default修饰的方法。

java 队列：

StringBuffer类与StringBuilder类详解：
	StringBuffer和StringBuilder都继承与AbstrctStringBuilder类。
	StringBuffer和StringBuilder的字符序列默认容量都为16。即初始化长度=参数长度+16。扩容规则为2n+2。(因为都是调用父类的扩容规则)
	StringBuffer和StringBuilder的构造器都是4个。
	capacity()方法返回字符串的容量大小
	length()方法返回字符串长度大小。
	StringBuffer重写了很多父类的方法。并且添加了Synchornized关键字来保持同步，牺牲了一定效率。在多线程环境下是线程安全的。
	StringBuilder则是线程不安全的。效率高于StringBuffer。
	StringBuffer中有个字段

default关键字只能在接口中使用，并且只能修饰方法。不能修饰变量。

Object.getClass()方法返回的是当前运行类的类对象。super.getClass()方法如果当前类的父类没有重写getClass()方法，则表示调用的Object.getClass()方法，依然返回当前类的类对象

定义在同一个包内的类可以不经过impor而直接引用

面向对象设计原则：
	开闭原则：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求
	里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能，也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法
	依赖倒置原则：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：面向接口编程，不要面向实现编程
		      以降低类间的耦合性。
	单一职责原则：
	接口隔离原则：


spring cloud 重要组件作用
	Eureka：服务发现与注册，分为Eureka Client和Eureka Service（注册中心）。每个服务都会作为Eureka Client被注册在Eureka Service中，
		同样。Eureka Client反过来可以拉取Eureka Service注册表。获取其他服务的信息。
	Ribbon：不同服务间发起请求的时候，是基于Ribbon来做的负载均衡，从一个服务的多台机器中选择一台。它采用的是Round Robin轮询算法。
	Feign：服务间的相互调用基于Feign的动态代理机制，根据@Feign、@RequestMapping等注解构建请求和服务器地址，然后发送请求，解析响应
	Hystrix：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务器雪崩的问题。
	Zuul：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务。

关于乱码问题解决方案：
	1.使用浏览器与服务器编码相匹配。
	2.tomcat默认的编码是ISO-8859-1。
	3.servlet中可以主动设置编码格式，来进行数据读取

java中原子操作包括：
	1.除了long和double之外的基本数据类型赋值操作
	2.所有引用的赋值操作
	3.java.concurrent.Atomic.*包中的所有类的一切操作

并发的三个概念：
	1.原子性：即一个或多个操作要么全部执行并且执行过程中不会被打断，要么都不执行。
	2.可见性：多个线程访问同一个变量时，一个线程改变了这个变量的值，其他线程能够立即看到修改后最新的值
	3.有序性：程序执行的顺序按代码的先后顺序执行。
指令重排序：
	1.编译器重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序
	2.处理器重排序：如果不存在数据依赖性。处理器可以改变语句对应的机器指令的执行顺序，CPU在指令重排序时会考虑指令之间的依赖性，
	   如果指令2必须依赖指令1的结果，那么CPU会保证指令1在指令2之前执行。
	注：指令重排序不保证程序中各个语句的执行顺序和代码一致，但会保证程序最终的执行结果和代码顺序执行的结果一致

java内存模型：
	每一个线程都有自己独立的工作内存，当线程修改一个变量时，

volatile关键字：
	1.可以保证数据域的可见性、有序性（禁止指令重排）、但不能保证原子性